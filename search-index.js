var searchIndex = {};
searchIndex['redis'] = {"items":[[0,"","redis","redis-rs is a rust implementation of a Redis client library.  It exposes\na general purpose interface to Redis and also provides specific helpers for\ncommonly used functionality."],[1,"Parser","","The internal redis response parser."],[1,"Client","","The client type."],[1,"Connection","","Represents a stateful redis TCP connection."],[1,"PubSub","","Represents a pubsub connection."],[1,"Msg","","Represents a pubsub message."],[1,"Cmd","","Represents redis commands."],[1,"Pipeline","","Represents a redis command pipeline."],[1,"Iter","","Represents a redis iterator."],[1,"Error","","Represents a redis error."],[11,"kind","","",0],[11,"desc","","",0],[11,"detail","","",0],[1,"InfoDict","","An info dictionary type."],[2,"Value","","Internal low-level redis value enum."],[12,"Nil","","A nil response from the server.",1],[12,"Int","","An integer response.  Note that there are a few situations\nin which redis actually returns a string for an integer which\nis why this library generally treats integers and strings\nthe same for all numeric responses.",1],[12,"Data","","An arbitary binary data.",1],[12,"Bulk","","A bulk response of more data.  This is generally used by redis\nto express nested structures.",1],[12,"Status","","A status response.",1],[12,"Okay","","A status response which represents the string \"OK\".",1],[2,"ErrorKind","","An enum of all error kinds."],[12,"ResponseError","","The server generated an invalid response.",2],[12,"TypeError","","Operation failed because of a type mismatch.",2],[12,"ExecAbortError","","A script execution was aborted.",2],[12,"BusyLoadingError","","The server cannot response because it's loading a dump.",2],[12,"NoScriptError","","A script that was requested does not actually exist.",2],[12,"ExtensionError","","A error that is unknown to the library.  This might be used\nby future redis servers or custom extensions.",2],[12,"InternalIoError","","An IO error was encountered while talking to the server.",2],[3,"parse_redis_value","","Parses bytes into a redis value."],[3,"cmd","","Shortcut function to creating a command with a single argument."],[3,"pipe","","Shortcut for creating a new pipeline."],[3,"pack_command","","Packs a bunch of commands into a request.  This is generally a quite\nuseless function as this functionality is nicely wrapped through the\n`Cmd` object, but in some cases it can be useful.  The return value\nof this can then be send to the low level `Connection` functions."],[3,"from_redis_value","","A shortcut function to invoke `FromRedisValue::from_redis_value`\nto make the API slightly nicer."],[10,"new","","Creates a new parser that parses the data behind the reader.  More\nthan one value can be behind the reader in which case the parser can\nbe invoked multiple times.  In other words: the stream does not have\nto be terminated.",3],[10,"parse_value","","parses a single value out of the stream.  If there are multiple\nvalues you can call this multiple times.  If the reader is not yet\nready this will block.",3],[10,"open","","Connects to a redis server and returns a client.  This does not\nactually open a connection yet but it does perform some basic\nchecks on the URL that might make the operation fail.",4],[10,"get_connection","","Instructs the client to actually connect to redis and returns a\nconnection object.  The connection object can be used to send\ncommands to the server.  This can fail with a variety of errors\n(like unreachable host) so it's important that you handle those\nerrors.",4],[10,"get_pubsub","","Returns a PubSub connection.  A pubsub connection can be used to\nlisten to messages coming in through the redis publish/subscribe\nsystem.",4],[10,"req_packed_command","","Sends an already encoded (packed) command into the TCP socket and\nreads the single response from it.",5],[10,"send_packed_command","","Sends an already encoded (packed) command into the TCP socket and\ndoes not read a response.  This is useful for commands like\n`MONITOR` which yield multiple items.  This needs to be used with\ncare because it changes the state of the connection.",5],[10,"recv_response","","Fetches a single response from the connection.  This is useful\nif used in combination with `send_packed_command`.",5],[10,"req_packed_commands","","Sends multiple already encoded (packed) command into the TCP socket\nand reads `count` responses from it.  This is used to implement\npipelining.",5],[10,"get_db","","Returns the database this connection is bound to.",5],[10,"subscribe","","Subscribes to a new channel.",6],[10,"psubscribe","","Subscribes to a new channel with a pattern.",6],[10,"unsubscribe","","Unsubscribes from a channel.",6],[10,"punsubscribe","","Unsubscribes from a channel with a pattern.",6],[10,"get_message","","Fetches the next message from the pubsub connection.  Blocks until\na message becomes available.  This currently does not provide a\nwait not to block :(",6],[10,"get_channel","","Returns the channel this message came on.",7],[10,"get_channel_name","","Convenience method to get a string version of the channel.  Unless\nyour channel contains non utf-8 bytes you can always use this\nmethod.  If the channel is not a valid string (which really should\nnot happen) then the return value is `\"?\"`.",7],[10,"get_payload","","Returns the message's payload in a specific format.",7],[10,"get_payload_bytes","","Returns the bytes that are the message's payload.  This can be used\nas an alternative to the `get_payload` function if you are interested\nin the raw bytes in it.",7],[10,"from_pattern","","Returns true if the message was constructed from a pattern\nsubscription.",7],[10,"get_pattern","","If the message was constructed from a message pattern this can be\nused to find out which one.  It's recommended to match against\nan `Option<String>` so that you do not need to use `from_pattern`\nto figure out if a pattern was set.",7],[10,"fmt","","",2],[10,"clone","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"looks_like_cursor","","Checks if the return value looks like it fulfils the cursor\nprotocol.  That means the result is a bulk item of length\ntwo with the first one being a cursor and the second a\nbulk response.",1],[10,"fmt","","",1],[10,"fmt","","",0],[10,"clone","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"simple","","",0],[10,"new","","Creates a new info dictionary from a string in the response of\nthe INFO command.  Each line is a key, value pair with the\nkey and value separated by a colon (`:`).  Lines starting with a\nhash (`#`) are ignored.",8],[10,"get","","Fetches a value by key and converts it into the given type.\nTypical types are `String`, `bool` and integer types.",8],[10,"find","","",8],[10,"contains_key","","",8],[10,"len","","",8],[10,"to_redis_args","collections::string","",9],[10,"to_redis_args","collections::vec","",10],[10,"to_redis_args","serialize::json","",11],[10,"from_redis_value","collections::string","",9],[10,"from_redis_value","collections::vec","",10],[10,"from_redis_value","std::collections::hashmap::map","",12],[10,"from_redis_value","std::collections::hashmap::set","",13],[10,"from_redis_value","redis","",1],[10,"from_redis_value","","",8],[10,"from_redis_value","serialize::json","",11],[10,"from_redis_value","core::option","",14],[10,"next","redis","",15],[10,"new","","Creates a new empty command.",16],[10,"arg","","Appends an argument to the command.  The argument passed must\nbe a type that implements `ToRedisArgs`.  Most primitive types as\nwell as vectors of primitive types implement it.",16],[10,"cursor_arg","","Works similar to `arg` but adds a cursor argument.  This is always\nan integer and also flips the command implementation to support a\ndifferent mode for the iterators where the iterator will ask for\nanother batch of items when the local data is exhausted.",16],[10,"get_packed_command","","Returns the packed command as a byte vector.",16],[10,"in_scan_mode","","Returns true if the command is in scan mode.",16],[10,"query","","Sends the command as query to the connection and converts the\nresult to the target redis value.  This is the general way how\nyou can retrieve data.",16],[10,"iter","","Similar to `query()` but returns an iterator over the items of the\nbulk result or iterator.  In normal mode this is not in any way more\nefficient than just querying into a `Vec<T>` as it's internally\nimplemented as buffering into a vector.  This however is useful when\n`cursor_arg` was used in which case the iterator will query for more\nitems until the server side cursor is exhausted.",16],[10,"execute","","This is a shortcut to `query()` that does not return a value and\nwill fail the task if the query fails because of an error.  This is\nmainly useful in examples and for simple commands like setting\nkeys.",16],[10,"new","","Creates an empty pipeline.  For consistency with the `cmd`\napi a `pipe` function is provided as alias.",17],[10,"cmd","","Starts a new command.  Functions such as `arg` then become\navailable to add more arguments to that command.",17],[10,"arg","","Adds an argument to the last started command.  This works similar\nto the `arg` method of the `Cmd` object.",17],[10,"ignore","","Instructs the pipeline to ignore the return value of this command.\nIt will still be ensured that it is not an error, but any successful\nresult is just thrown away.  This makes result processing through\ntuples much easier because you do not need to handle all the items\nyou do not care about.",17],[10,"atomic","","This enables atomic mode.  In atomic mode the whole pipeline is\nenclosed in `MULTI`/`EXEC`.  From the user's point of view nothing\nchanges however.  This is easier than using `MULTI`/`EXEC` yourself\nas the format does not change.",17],[10,"query","","Executes the pipeline and fetches the return values.  Since most\npipelines return different types it's recommended to use tuple\nmatching to process the results:",17],[10,"execute","","This is a shortcut to `query()` that does not return a value and\nwill fail the task if the query of the pipeline fails.",17],[4,"RedisResult","","Library generic result type."],[6,"FromRedisValue","","This trait is used to convert a redis value into a more appropriate\ntype.  While a redis `Value` can represent any response that comes\nback from the redis server, usually you want to map this into something\nthat works better in rust.  For instance you might want to convert the\nreturn value into a `String` or an integer."],[9,"from_redis_value","","Given a redis `Value` this attempts to convert it into the given\ndestination type.  If that fails because it's not compatible an\nappropriate error is generated.",18],[6,"ToRedisArgs","","Used to convert a value into one or multiple redis argument\nstrings.  Most values will produce exactly one item but in\nsome cases it might make sense to produce more than one."],[9,"to_redis_args","","This converts the value into a vector of bytes.  Each item\nis a single argument.  Most items generate a vector of a\nsingle item.",19]],"paths":[[1,"Error"],[2,"Value"],[2,"ErrorKind"],[1,"Parser"],[1,"Client"],[1,"Connection"],[1,"PubSub"],[1,"Msg"],[1,"InfoDict"],[1,"String"],[1,"Vec"],[2,"Json"],[1,"HashMap"],[1,"HashSet"],[2,"Option"],[1,"Iter"],[1,"Cmd"],[1,"Pipeline"],[6,"FromRedisValue"],[6,"ToRedisArgs"]]};
initSearch(searchIndex);
